/* SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only                     */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include "strutil.h"
#include "stringlists.h"

#define ObjExtension ".o"

static StringRecPtr inc_path_list = NULL;

static char *getobj(const char *pSrc)
{
  static char buffer[255];
  int l = strlen(pSrc), bm5 = sizeof(buffer) - 5;
  char *pSearch;

  if (l < bm5)
    l = bm5;
  memcpy(buffer, pSrc, l); buffer[l] = '\0';

  pSearch = strrchr(buffer, '.');
  if (pSearch)
    strcpy(pSearch, ObjExtension);

  return buffer;
}

int MayRecurse(const char *pFileName)
{
  int l = strlen(pFileName);

  /* .rsc files are autogenerated and do not contain any
     include statements - no need to scan them */

  if ((l > 4) && (!strcmp(pFileName + l - 4, ".rsc")))
    return 0;

  return 1;
}

static void ParseFile(const char *pFileName, const char *pParentFileName, StringRecPtr *pFileList)
{
  FILE *pFile;
  int l, file_stat;
  char line[512], *pCmd, *pName;
  String raw_name, eff_name;
  struct stat stat_buf;

  pFile = fopen(pFileName, "r");
  if (!pFile)
  {
    if (pParentFileName)
      fprintf(stderr, "%s: ", pParentFileName);
    perror(pFileName);
    return;
  }

  while (!feof(pFile))
  {
    if (!fgets(line, sizeof(line), pFile))
      break;
    l = strlen(line);
    if ((l > 0) && (line[l - 1] == '\n'))
      line[l - 1] = '\0';

    if (*line != '#')
      continue;
    pCmd = strtok(line + 1, " \t");
    if (strcmp(pCmd, "include"))
      continue;

    pName = strtok(NULL, " \t");
    if (!pName)
      continue;
    l = strlen(pName);
    if ((*pName != '"') || (pName[l - 1] != '"'))
      continue;

    if (l - 1 < (int)sizeof(raw_name))
    {
      memcpy(raw_name, pName + 1, l - 2);
      raw_name[l - 2] = '\0';
      strmaxcpy(eff_name, raw_name, sizeof(eff_name));
      file_stat = stat(eff_name, &stat_buf);
      if (file_stat)
      {
        StringRecPtr p_run;
        const char *p_path;

        for (p_path = GetStringListFirst(inc_path_list, &p_run);
             p_path; p_path = GetStringListNext(&p_run))
        {
          size_t l = strlen(p_path);
          Boolean term_path = (l > 0) && ((p_path[l -1] == '/') || (p_path[l -1] == '\\'));
          as_snprintf(eff_name, sizeof(eff_name), "%s%s%s", p_path, term_path ? "" : "/", raw_name);
          file_stat = stat(eff_name, &stat_buf);
          if (!file_stat)
            break;
        }
      }
      /* If file is not present, it is created dynamically and expected to appear in the
         object subdirectory, which is passed in as -I path.  Keep last generated eff_name
         for the dependency list: */
      if (!StringListPresent(*pFileList, eff_name))
      {
        AddStringListLast(pFileList, eff_name);
        if (MayRecurse(eff_name))
          ParseFile(eff_name, pFileName, pFileList);
      }
    }
  }
  fclose(pFile);
}

int main(int argc, char **argv)
{
  int z, ArgsAreObj = 0;
  FILE *pDestFile;
  char *pDestFileName = NULL, *pIncFileName, *pObjExtension = NULL, *pSrcFileName;
  char used[1024], SrcFileName[512];
  StringRecPtr FileList, SrcList;

  if (argc < 2)
  {
    fprintf(stderr, "usage: %s [args] <file(s)>\n", *argv);
    exit(1);
  }

  memset(used, 0, sizeof(used));

  for (z = 1; z < argc; z++)
    if ((!used[z]) && (*argv[z] == '-'))
    {
      used[z] = 1;
      if (!strcmp(argv[z] + 1, "o"))
      {
        if (z >= argc - 1)
          pDestFileName = NULL;
        else
        {
          pDestFileName = argv[z + 1];
          used[z + 1] = 1;
        }
      }
      else if (!strcmp(argv[z] + 1, "c"))
      {
        if (z >= argc - 1)
          pObjExtension = NULL;
        else
        {
          pObjExtension = argv[z + 1];
          used[z + 1] = 1;
        }
      }
      else if (!strcmp(argv[z] + 1, "r"))
      {
        ArgsAreObj = 1;
      }
      else if (!strcmp(argv[z] + 1, "I"))
      {
        if (z < argc - 1)
        {
          AddStringListLast(&inc_path_list, argv[z + 1]);
          used[z + 1] = 1;
        }
      }
      else
      {
        fprintf(stderr, "unknown option: %s\n", argv[z]);
        exit(2);
      }
    }

  if (pDestFileName)
  {
    pDestFile = fopen(pDestFileName, "w");
    if (!pDestFile)
    {
      perror(pDestFileName);
      exit(errno);
    }
  }
  else
    pDestFile = stdout;

  fprintf(pDestFile, "# auto-generated by %s - do not edit\n\n", *argv);

  InitStringList(&FileList);
  InitStringList(&SrcList);
  for (z = 1; z < argc; z++)
  {
    if (used[z])
      continue;

    /* object files may be in paths different than root - strip path to deduce associated src file */

    if (ArgsAreObj)
    {
      char *pRun;

      for (pRun = argv[z] + strlen(argv[z]); pRun > argv[z]; pRun--)
        if ((*(pRun - 1) == '/') || (*(pRun - 1) == '\\'))
          break;
      /* leading h_ in object file name is used for host-side files */
      if (!strncmp(pRun, "h_", 2))
        pRun += 2;
      *SrcFileName = '\0'; strncat(SrcFileName, pRun, sizeof(SrcFileName) - 1);
      if (pObjExtension)
      {
        int l1 = strlen(SrcFileName), l2 = strlen(pObjExtension);

        if ((l1 > l2) && !memcmp(SrcFileName + l1 - l2, pObjExtension, l2))
          strcpy(SrcFileName + l1 - l2, ".c");
      }
      pSrcFileName = SrcFileName;
    }
    else
      pSrcFileName = argv[z];
    ClearStringList(&FileList);
    AddStringListLast(&SrcList, pSrcFileName);
    ParseFile(pSrcFileName, NULL, &FileList);

    if (!StringListEmpty(FileList))
    {
      fprintf(pDestFile, "%s: %s", ArgsAreObj ? argv[z] : getobj(argv[z]), pSrcFileName);
      while (True)
      {
        pIncFileName = MoveAndCutStringListFirst(&FileList);
        if (pIncFileName)
        {
          if (*pIncFileName)
            fprintf(pDestFile, " %s", pIncFileName);
          free(pIncFileName); pIncFileName = NULL;
        }
        else
          break;
      }
      fprintf(pDestFile, "\n\n");
    }
  }

  if (pDestFileName)
  {
    if (!StringListEmpty(SrcList))
    {
      fprintf(pDestFile, "%s:", pDestFileName);
      while (True)
      {
        pIncFileName = MoveAndCutStringListFirst(&SrcList);
        if (pIncFileName)
        {
          if (*pIncFileName)
            fprintf(pDestFile, " %s", pIncFileName);
          free(pIncFileName); pIncFileName = NULL;
        }
        else
          break;
      }
      fprintf(pDestFile, "\n");
    }
    fclose(pDestFile);
  }

  ClearStringList(&inc_path_list);

  return 0;
}
